{"entries":[{"timestamp":1731872812613,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n"],[-1,"class Point {\n    x: number\n    y: number\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n\n    move(){\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n}"]],"start1":0,"start2":0,"length1":203,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"pt-only\""],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":280,"start2":280,"length1":11,"length2":42}]}]},{"timestamp":1731873247487,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"(){\n"],[-1,"        \n    }\n    \n\n    moveTail() {\n"],[0,"    "]],"start1":122,"start2":122,"length1":46,"length2":8},{"diffs":[[0,"   }"],[-1,"\n\n    display(){\n\n    }"],[0,"\n}"]],"start1":197,"start2":197,"length1":29,"length2":6}]}]},{"timestamp":1731873846042,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"this.moveTail();"],[0,"\n"],[1,""],[0,"    "]],"start1":130,"start2":130,"length1":25,"length2":9},{"diffs":[[0,") {\n"],[-1,"        led.unplot(this.queue2.x, this.queue2.y)\n"],[0,"    "]],"start1":160,"start2":160,"length1":57,"length2":8},{"diffs":[[0,"(){\n"],[-1,"        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)"],[0,"\n   "]],"start1":252,"start2":252,"length1":148,"length2":8}]}]},{"timestamp":1731874344495,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ber\n"],[-1,"\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(){\n\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }"],[1,"}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n\n    move(){\n        this.moveTail();\n    }\n    "],[0,"\n\n  "]],"start1":39,"start2":39,"length1":1042,"length2":126}]}]},{"timestamp":1731874924052,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ion("],[-1,"isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = isLeft ? 'S' : 'N';\n                break;\n        }"],[1,"){\n"],[0,"\n   "]],"start1":416,"start2":416,"length1":469,"length2":11},{"diffs":[[0," }\n}"],[-1,"\n\nconst snake = new Snake();\n\nforever(()=>{\n    \n})"]],"start1":1381,"start2":1381,"length1":55,"length2":4}]}]},{"timestamp":1731875440293,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"int\n"],[-1,"    oldQueue: Point\n"],[0,"    "]],"start1":195,"start2":195,"length1":28,"length2":8},{"diffs":[[0,"    "],[-1,"this.oldQueue = new Poin"],[1,"led.unplo"],[0,"t(th"]],"start1":1558,"start2":1558,"length1":32,"length2":17},{"diffs":[[0,"(){\n"],[-1,"        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n"],[0,"    "]],"start1":1691,"start2":1691,"length1":110,"length2":8},{"diffs":[[0,"=>{\n"],[1,""],[0,"    "],[-1,"snake.move()"],[0,"\n})"]],"start1":1883,"start2":1883,"length1":23,"length2":11}]}]},{"timestamp":1731875774805,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s.orientation = "],[-1,"!"],[0,"isLeft ? 'O':'E'"]],"start1":535,"start2":535,"length1":33,"length2":32},{"diffs":[[0,"s.orientation = "],[-1,"!"],[0,"isLeft ? 'N' : '"]],"start1":633,"start2":633,"length1":33,"length2":32},{"diffs":[[0,"s.orientation = "],[-1,"!"],[0,"isLeft ? 'E' : '"]],"start1":733,"start2":733,"length1":33,"length2":32},{"diffs":[[0,"ation = "],[-1,"!"],[0,"isLeft ?"]],"start1":841,"start2":841,"length1":17,"length2":16},{"diffs":[[0,");\n\n"],[-1,"input.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\n\nforever(()=>{\n    snake.move()\n    snake.display();\n    basic.pause(500);"],[1,"forever(()=>{\n    snake.move()"],[0,"\n})"]],"start1":2006,"start2":2006,"length1":218,"length2":37}]}]},{"timestamp":1731876363353,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"use("],[-1,"3"],[1,"5"],[0,"00);"]],"start1":2216,"start2":2216,"length1":9,"length2":9}]}]},{"timestamp":1731876388696,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"alse))\n\n"],[-1,"\n\n"],[0,"forever("]],"start1":2144,"start2":2144,"length1":18,"length2":16}]}]},{"timestamp":1731878291889,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"))\n\n"],[-1,"let pause = "],[0,"\n\nfo"]],"start1":2148,"start2":2148,"length1":20,"length2":8}]}]},{"timestamp":1731878296919,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e = "],[-1,"false;"],[0,"\n\nfo"]],"start1":2160,"start2":2160,"length1":14,"length2":8},{"diffs":[[0,"=>{\n"],[-1,"    if(!pause){\n    "],[0,"    "]],"start1":2176,"start2":2176,"length1":28,"length2":8},{"diffs":[[0,".move()\n"],[-1,"    "],[0,"    snak"]],"start1":2189,"start2":2189,"length1":20,"length2":16},{"diffs":[[0,".display();\n"],[-1,"    "],[0,"    basic.pa"]],"start1":2206,"start2":2206,"length1":28,"length2":24},{"diffs":[[0,"e(300);\n"],[-1,"    }\n"],[0,"})"]],"start1":2232,"start2":2232,"length1":16,"length2":10}]}]},{"timestamp":1731878314856,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"alse))\n\n"],[-1,"\n"],[0,"let paus"]],"start1":2144,"start2":2144,"length1":17,"length2":16}]}]},{"timestamp":1731879281090,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e))\n"],[-1,"input.onL"],[0,"\n\nle"]],"start1":2147,"start2":2147,"length1":17,"length2":8}]}]},{"timestamp":1731879284294,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n\nc"],[-1,"lass Score{\n    counter :number\n    constructor(){\n        this.counter = 0;\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n}\n\nconst snake = new Snake();\nconst score = new Score();\nlet localPause = false"],[1,"onst snake = new Snake()"],[0,";\n\ni"]],"start1":1983,"start2":1983,"length1":228,"length2":32},{"diffs":[[0,".onL"],[-1,"ogoEvent(TouchButtonEvent.Released, () => {\n    localPause = !localPause\n    if (localPause){\n        score.show();\n    }\n})"],[1,"\n\nlet pause = false;"],[0,"\n\nfo"]],"start1":2156,"start2":2156,"length1":132,"length2":28},{"diffs":[[0,"  if"],[-1," "],[0,"(!"],[-1,"localP"],[1,"p"],[0,"ause"]],"start1":2198,"start2":2198,"length1":17,"length2":11}]}]},{"timestamp":1731879870573,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"    equals(point: Point): boolean {\n        return point.x === this.x && point.y === this.y;\n    }\n"],[0,"}\n\nc"]],"start1":125,"start2":125,"length1":107,"length2":8},{"diffs":[[0,"  }\n"],[-1,"    checkEmptyPlace(point: Point):boolean{\n        return !this.center.equals(point) &&\n            !this.queue1.equals(point) && \n            !this.queue2.equals(point);\n    }\n}\n\nclass Score{\n    counter :number\n    constructor(){\n        this.counter = 0;\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n    hide(){\n        basic.showString(\"\")\n    }\n    findEmptyPlace(): Point{\n        const p = new Point(randint(0, 4), randint(0, 4));\n        if(snake.checkEmptyPlace(p))"],[1,"}\n\nclass Score{\n    counter :number\n    constructor(){\n        this.counter = 0;\n    }\n    show(){\n        basic.showNumber(this.counter);"],[0,"\n   "]],"start1":1979,"start2":1979,"length1":501,"length2":146},{"diffs":[[0,"();\n"],[-1,"    }else{\n        score.hide();\n"],[0,"    "]],"start1":2468,"start2":2468,"length1":41,"length2":8}]}]},{"timestamp":1731880466552,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ber\n"],[-1,"    pointToWin: Point\n"],[0,"    "]],"start1":2291,"start2":2291,"length1":30,"length2":8},{"diffs":[[0," 0;\n"],[-1,"        this.pointToWin = this.findEmptyPlace();\n"],[0,"    "]],"start1":2336,"start2":2336,"length1":57,"length2":8},{"diffs":[[0,"(p))"],[-1,"{\n            return p;\n        }\n        return this.findEmptyPlace();\n    }\n    showPoint(){\n        if(this.pointToWin != null){\n            led.plot(this.pointToWin.x, this.pointToWin.y)\n        }\n    }\n    checkWin(snake :Snake){\n        if(snake.center.equals(this.pointToWin)){\n            this.counter++;\n            this.pointToWin = this.findEmptyPlace();\n        }"],[0,"\n   "]],"start1":2571,"start2":2571,"length1":383,"length2":8},{"diffs":[[0,"ve()"],[-1,";\n        score.checkWin(snake);\n        snake.display();\n        score.showPoint"],[1,"\n        snake.display"],[0,"();\n"]],"start1":3021,"start2":3021,"length1":89,"length2":30}]}]},{"timestamp":1731880992615,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   }\n}\n\n"],[-1,"\n\n"],[0,"const sn"]],"start1":3023,"start2":3023,"length1":18,"length2":16}]}]},{"timestamp":1731918475619,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"function too"],[0,"\n\nco"]],"start1":3027,"start2":3027,"length1":20,"length2":8}]}]},{"timestamp":1731918478600,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n to"],[-1,"gglePause(){\n    localPause = !localPause\n    if (localPause) {\n        score.show();\n    } else {\n        score.hide();\n    }\n}"],[1,"o"],[0,"\n\nco"]],"start1":3038,"start2":3038,"length1":136,"length2":9},{"diffs":[[0,"ed, "],[-1,"togglePause"],[1,"() => {\n    localPause = !localPause\n    if (localPause){\n        score.show();\n    }else{\n        score.hide();\n    }\n}"],[0,")\n\nf"]],"start1":3302,"start2":3302,"length1":19,"length2":128}]}]},{"timestamp":1731941498016,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":208,"start2":208,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// les tests vont ici ; cela ne sera pas compilé si ce paquet est utilisé en tant qu'extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1731872812612,"editorVersion":"7.0.51","text":{"main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1731874613796,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(){\n\n    }\n\n    move(){\n        this.moveHead();\n        this.moveTail();\n    }\n    \n    moveHead(){\n        \n    }\n\n    moveTail() {\n        led.unplot(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n}","README.md":"","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1731878291889,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    oldQueue: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = !isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = !isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = !isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = !isLeft ? 'S' : 'N';\n                break;\n        }\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }\n\n    moveTail() {\n        this.oldQueue = new Point(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n}\n\nconst snake = new Snake();\n\ninput.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\n\nforever(()=>{\n    snake.move()\n    snake.display();\n    basic.pause(300);\n})","README.md":"","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1731880093537,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    oldQueue: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = !isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = !isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = !isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = !isLeft ? 'S' : 'N';\n                break;\n        }\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }\n\n    moveTail() {\n        this.oldQueue = new Point(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n}\n\nclass Score{\n    counter :number\n    constructor(){\n        this.counter = 0;\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n}\n\nconst snake = new Snake();\nconst score = new Score();\nlet localPause = false;\n\ninput.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\ninput.onLogoEvent(TouchButtonEvent.Released, () => {\n    localPause = !localPause\n    if (localPause){\n        score.show();\n    }else{\n        score.hide();\n    }\n})\n\nforever(()=>{\n    if (!localPause){\n        snake.move()\n        snake.display();\n        basic.pause(300);\n    }\n})","README.md":"","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1731918475619,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n    equals(point: Point): boolean {\n        return point.x === this.x && point.y === this.y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    oldQueue: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = !isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = !isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = !isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = !isLeft ? 'S' : 'N';\n                break;\n        }\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }\n\n    moveTail() {\n        this.oldQueue = new Point(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n    checkEmptyPlace(point: Point):boolean{\n        return !this.center.equals(point) &&\n            !this.queue1.equals(point) && \n            !this.queue2.equals(point);\n    }\n}\n\nclass Score{\n    counter :number\n    pointToWin: Point\n    constructor(){\n        this.counter = 0;\n        this.pointToWin = this.findEmptyPlace();\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n    hide(){\n        basic.showString(\"\")\n    }\n    findEmptyPlace(): Point{\n        const p = new Point(randint(0, 4), randint(0, 4));\n        if(snake.checkEmptyPlace(p)){\n            return p;\n        }\n        return this.findEmptyPlace();\n    }\n    showPoint(){\n        if(this.pointToWin != null){\n            led.plot(this.pointToWin.x, this.pointToWin.y)\n        }\n    }\n    checkWin(snake :Snake){\n        if(snake.center.equals(this.pointToWin)){\n            this.counter++;\n            this.pointToWin = this.findEmptyPlace();\n        }\n    }\n}\n\nconst snake = new Snake();\nconst score = new Score();\nlet localPause = false;\n\ninput.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\ninput.onLogoEvent(TouchButtonEvent.Released, () => {\n    localPause = !localPause\n    if (localPause){\n        score.show();\n    }else{\n        score.hide();\n    }\n})\n\nforever(()=>{\n    if (!localPause){\n        snake.move();\n        score.checkWin(snake);\n        snake.display();\n        score.showPoint();\n        basic.pause(300);\n    }\n})","README.md":"","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1731936742087,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n    equals(point: Point): boolean {\n        return point.x === this.x && point.y === this.y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    oldQueue: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = !isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = !isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = !isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = !isLeft ? 'S' : 'N';\n                break;\n        }\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }\n\n    moveTail() {\n        this.oldQueue = new Point(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n    checkEmptyPlace(point: Point):boolean{\n        return !this.center.equals(point) &&\n            !this.queue1.equals(point) && \n            !this.queue2.equals(point);\n    }\n}\n\nclass Score{\n    counter :number\n    pointToWin: Point\n    constructor(){\n        this.counter = 0;\n        this.pointToWin = this.findEmptyPlace();\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n    hide(){\n        basic.showString(\"\")\n    }\n    findEmptyPlace(): Point{\n        const p = new Point(randint(0, 4), randint(0, 4));\n        if(snake.checkEmptyPlace(p)){\n            return p;\n        }\n        return this.findEmptyPlace();\n    }\n    showPoint(){\n        if(this.pointToWin != null){\n            led.plot(this.pointToWin.x, this.pointToWin.y)\n        }\n    }\n    checkWin(snake :Snake){\n        if(snake.center.equals(this.pointToWin)){\n            this.counter++;\n            this.pointToWin = this.findEmptyPlace();\n        }\n    }\n}\n\nfunction togglePause(){\n    localPause = !localPause\n    if (localPause) {\n        score.show();\n    } else {\n        score.hide();\n    }\n}\n\nconst snake = new Snake();\nconst score = new Score();\nlet localPause = false;\n\ninput.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\ninput.onLogoEvent(TouchButtonEvent.Released, togglePause)\n\nforever(()=>{\n    if (!localPause){\n        snake.move();\n        score.checkWin(snake);\n        snake.display();\n        score.showPoint();\n        basic.pause(300);\n    }\n})","README.md":"# Coder son Snake en Javascript - Microbit\r\n\r\nNous allons coder ensemble un mini jeu de snake avec Microbit\r\n\r\n## Règles du jeu\r\n\r\nLe serpent à une longueur de 3.\r\nDes pommes apparaissent aléatoirement. Lorsque le serpent passe dessus, il marque un point.\r\nLe bouton A permet de tourner à gauche, le bouton à droite.\r\nL'appui sur le logo permet de mettre en pause et d'afficher le score.\r\nLe serpent peut passer à travers les murs, il apparaît alors de l'autre côté\r\n\r\n## Etapes\r\n\r\nVoici les étapes pour construire facilement votre serpent\r\n\r\n* Afficher le serpent\r\n* L'animer en le faisant avancer dans la même direction\r\n* Connecter les boutons A et B pour changer ","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1731941498016,"editorVersion":"7.0.51","text":{"main.ts":"\nclass Point {\n    x: number\n    y: number\n\n    constructor(x: number, y: number){\n        this.x = x;\n        this.y = y;\n    }\n    equals(point: Point): boolean {\n        return point.x === this.x && point.y === this.y;\n    }\n}\n\nclass Snake{\n    center :Point\n    queue1: Point\n    queue2: Point\n    oldQueue: Point\n    orientation: string\n\n    constructor(){\n        this.orientation = 'E'\n        this.center = new Point(2, 2);\n        this.queue1 = new Point(2, 2);\n        this.queue2 = new Point(2, 2);\n    }\n\n    changeOrientation(isLeft: boolean){\n        switch (this.orientation) {\n            case 'N':\n                this.orientation = !isLeft ? 'O':'E';\n                break;\n            case 'E':\n                this.orientation = !isLeft ? 'N' : 'S';\n                break;\n            case 'S':\n                this.orientation = !isLeft ? 'E' : 'O';\n                break;\n            case 'O':\n                this.orientation = !isLeft ? 'S' : 'N';\n                break;\n        }\n    }\n\n    move(){\n        this.moveTail();\n        this.moveHead();\n    }\n    \n    moveHead(){\n        switch(this.orientation){\n            case 'N': \n                this.center = new Point((this.center.x + 4) % 5, this.center.y);\n                break;\n            case 'E': \n                this.center = new Point(this.center.x, (this.center.y + 1) % 5);\n                break;\n            case 'S': \n                this.center = new Point((this.center.x + 1) % 5, this.center.y);\n                break;\n            case 'O': \n                this.center = new Point(this.center.x, (this.center.y + 4) % 5);\n                break;\n        }\n    }\n\n    moveTail() {\n        this.oldQueue = new Point(this.queue2.x, this.queue2.y)\n        this.queue2 = this.queue1;\n        this.queue1 = this.center;\n    }\n\n    display(){\n        if(this.oldQueue != null){\n            led.unplot(this.oldQueue.x, this.oldQueue.y)\n        }\n        led.plot(this.center.x, this.center.y)\n        led.plot(this.queue1.x, this.queue1.y)\n        led.plot(this.queue2.x, this.queue2.y)\n    }\n    checkEmptyPlace(point: Point):boolean{\n        return !this.center.equals(point) &&\n            !this.queue1.equals(point) && \n            !this.queue2.equals(point);\n    }\n}\n\nclass Score{\n    counter :number\n    pointToWin: Point\n    constructor(){\n        this.counter = 0;\n        this.pointToWin = this.findEmptyPlace();\n    }\n    show(){\n        basic.showNumber(this.counter);\n    }\n    hide(){\n        basic.showString(\"\")\n    }\n    findEmptyPlace(): Point{\n        const p = new Point(randint(0, 4), randint(0, 4));\n        if(snake.checkEmptyPlace(p)){\n            return p;\n        }\n        return this.findEmptyPlace();\n    }\n    showPoint(){\n        if(this.pointToWin != null){\n            led.plot(this.pointToWin.x, this.pointToWin.y)\n        }\n    }\n    checkWin(snake :Snake){\n        if(snake.center.equals(this.pointToWin)){\n            this.counter++;\n            this.pointToWin = this.findEmptyPlace();\n        }\n    }\n}\n\nfunction togglePause(){\n    localPause = !localPause\n    if (localPause) {\n        score.show();\n    } else {\n        score.hide();\n    }\n}\n\nconst snake = new Snake();\nconst score = new Score();\nlet localPause = false;\n\ninput.onButtonPressed(Button.A, ()=>snake.changeOrientation(true))\ninput.onButtonPressed(Button.B, () => snake.changeOrientation(false))\ninput.onLogoEvent(TouchButtonEvent.Released, togglePause)\n\nforever(()=>{\n    if (!localPause){\n        snake.move();\n        score.checkWin(snake);\n        snake.display();\n        score.showPoint();\n        basic.pause(300);\n    }\n})","README.md":"# Coder son Snake en Javascript - Microbit\r\n\r\nNous allons coder ensemble un mini jeu de snake avec Microbit\r\n\r\n## Règles du jeu\r\n\r\nLe serpent à une longueur de 3.\r\nDes pommes apparaissent aléatoirement. Lorsque le serpent passe dessus, il marque un point.\r\nLe bouton A permet de tourner à gauche, le bouton à droite.\r\nL'appui sur le logo permet de mettre en pause et d'afficher le score.\r\nLe serpent peut passer à travers les murs, il apparaît alors de l'autre côté\r\n\r\n## Etapes\r\n\r\nVoici les étapes pour construire facilement votre serpent\r\n\r\n* Le serpent\r\n    * Afficher le serpent composé d'une tête et de deux points de la queue\r\n    * L'animer en le faisant avancer dans la même direction\r\n    * Connecter les boutons A et B pour changer la direction du serpent : A à gauche, B à droite\r\n    * Prendre en compte la direction au serpent\r\n* Score\r\n    * Gérer la pause lors du click sur le logo\r\n    * Afficher le score lorsqu'on est sur pause\r\n    * Générer la position d'une pomme dans la matrice là où ne se trouve pas le serpent et l'afficher\r\n    * Lorsque le serpent (sa tête) passe sur la pomme, ajouter un point et regénérer une pomme","pxt.json":"{\n    \"name\": \"Little snake\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1731941498021}